\documentclass[mscthesis, 11pt]{usiinfthesis}
\usepackage{lipsum}
\setlength{\parindent}{0em}
\setlength{\parskip}{0.5em}
\usepackage{placeins}

\usepackage{minted}
\usepackage{xargs}
\usepackage{listings}
\usepackage{float}
\usepackage{subcaption}
\usepackage{changepage}
\usepackage{xcolor}
\usepackage{colortbl}
\usepackage{syntax}
\usepackage{bm}
\definecolor{identbefore}{HTML}{fce6e8}
\definecolor{identafter}{HTML}{dbffde} 
\usemintedstyle{emacs}
\AtBeginEnvironment{minted}{%
  \renewcommand{\fcolorbox}[4][]{#4}}
%\renewcommand{\arraystretch}{0.5}

\BeforeBeginEnvironment{minted}{\vspace{0.1cm}}
\AfterEndEnvironment{minted}{\vspace{-0.5cm}}


\graphicspath{{figures/}}
%\usepackage{pythonhighlight}

\lstdefinelanguage{algebra}
{morekeywords={import,sort,constructors,observers,transformers,axioms,if,
else,end},
sensitive=false,
morecomment=[l]{//s},
}

\lstset{language=python,linewidth=0.95\linewidth,breaklines=true,numbers=left, 
basicstyle=\ttfamily,numberstyle=\tiny,escapeinside={//*}{\^^M},
mathescape=true}

\setmintedinline{escapeinside=||,mathescape=true, fontsize=\normalsize, 
autogobble=true,
resetmargins=true,
breaklines=true,
}

\newcommandx{\UnresolvedSymbol}[1][1=$sym$]{
	\mintinline{text}{UnresolvedSymbol(|#1|: str)}}

\newcommandx{\TermUnresolvedSymbol}[1][1=$sym$]{
	\mintinline{text}{UnresolvedSymbol(|#1|: str)}}

\newcommandx{\PatternVariable}[1][1=$pv$]{
	\mintinline{text}{PatternVariable(|#1|: str)}}

\newcommandx{\PatternSequence}[2][1=$p_1$, 2=$p_n$]{%
	\mintinline{text}{PatternSequence([|#1|,|$...$|,|#2|] : Pattern?)}}

\newcommandx{\TermSequence}[2][1=$t_1$, 2=$t_n$]{%
	\mintinline{text}{TernSequence([|#1|,|$...$|,|#2|] : TermTemplate?)}}

\newcommandx{\PatternRepeat}[1][1=$p_r$]{%
	\mintinline{text}{Repeat(|#1|: Pattern)}}

\newcommandx{\TermRepeat}[1][1=$t_r$]{%
	\mintinline{text}{Repeat(|#1|: TermTemplate)}}

%\newcommand{\TermRepeat}{\lstinline[mathescape]!Repeat($t_r$: TermTemplate)! } 


\newcommandx{\BuiltInPatternNoArg}{%
	{\mintinline{text}{BuiltInPattern}}}
\newcommandx{\PatternSequenceNoArg}{%
	{\mintinline{text}{PatternSequence}}}
\newcommandx{\PatternInHoleNoArg}{%
	{\mintinline{text}{InHole}}}
\newcommandx{\PythonCallNoArg}{%
	{\mintinline{text}{PythonCall}}}

\newcommandx{\MetafunctionApplicationNoArgs}{%
	{\mintinline{text}{MetafunctionApplication}}}


\newcommandx{\ConstraintCheckNoArg}{%
	{\mintinline{text}{ConstraintCheck}}}

\newcommandx{\TermSequenceNoArg}{%
	{\mintinline{text}{TermSequence}}}

\newcommandx{\NonTerminalNoArg}{%
	{\mintinline{text}{NonTerminal}}}

\newcommandx{\LiteralPatternNoArg}{%
	{\mintinline{text}{Literal}}}

\newcommandx{\DefineLanguageNoArg}{%
	{\mintinline{text}{DefineLanguage}} }

\newcommandx{\MakeAnnotation}[3]{%
{\mintinline{text}{|#1|.addannotation(#2, |#3|)}}}

\newcommandx{\BuiltInPattern}[3][1=$tag$, 2=$pv$, 3=true]{%
\ifthenelse{\boolean{#3}} 
	{\mintinline{text}{BuiltInPattern(|#1|: BuiltInPatternKind, |#2|: str)}}
	{\mintinline{text}{BuiltInPattern(|#1|, |#2|)}}}

\newcommandx{\NonTerminal}[3][1=$nt$, 2=$pv$, 3=true]{%
	\ifthenelse{\boolean{#3}} 
	{\mintinline{text}{NonTerminal(|#1|: str, |#2|: str)}} 
	{\mintinline{text}{NonTerminal(|#1|, |#2|)}}}

\newcommandx{\PatternInHole}[5][1=$p_1$, 2=$p_2$, 3=$c_1$, 4=$c_n$, 5=true]{%
	\ifthenelse{\boolean{#5}} 
	{\mintinline{text}{InHole(|#1|: Pattern, |#2|: Pattern, [|#3|,|$...$|,|#4|]: CheckConstraint?)}}
	{\mintinline{text}{InHole(|#1|, |#2|, [|#3|,|$...$|,|#4|])}}}

\newcommandx{\TermInHole}[3][1=$t_1$, 2=$t_2$, 3=true]{%
	\ifthenelse{\boolean{#3}} 
	{\mintinline{text}{InHole(|#1|: TermTemplate, |#2|: TermTemplate)}}
	{\mintinline{text}{InHole(|#1|, |#2|)}}}

\newcommandx{\LiteralPattern}[3][1=$kind$, 2=$v$, 3=true]{%
	\ifthenelse{\boolean{#3}}
	{\mintinline{text}{Literal(|#1|: PatternLiteralKind, |#2|: Any)}} 
	{\mintinline{text}{Literal(|#1|, |#2|)}}}

\newcommandx{\TermLiteral}[3][1=$kind$, 2=$v$, 3=true]{%
	\ifthenelse{\boolean{#3}}
	{\mintinline{text}{Literal(|#1|: TermLiteralKind, |#2|: Any)}} 
	{\mintinline{text}{Literal(|#1|, |#2|)}}}



\newcommandx{\PatternCheckConstraint}[3][1=$sym_1$, 2=$sym_2$, 3=true]{%
	\ifthenelse{\boolean{#3}} 
	{\mintinline{text}{CheckConstraint(|#1|: str, |#2|: str)}}
	{\mintinline{text}{CheckConstraint(|#1|, |#2|)}}}


\newcommandx{\NtDefinitionN}[4][1=$nt$, 2=$p_1$, 3=$p_n$, 4=true]{%
	\ifthenelse{\boolean{#4}}
	{\mintinline{text}{NtDefinition(|#1|: NonTerminal, [|#2|, |$...$|, |#3|]: Pattern)}}
	{\mintinline{text}{(NtDefinition|#1|, [|#2|, |$...$|, |#3|])}}}


\newcommandx{\PythonCall}[4][1=$nt$, 2=$t_1$, 3=$t_n$, 4=true]{%
	\ifthenelse{\boolean{#4}}
	{\mintinline{text}{PythonCall(|#1|: PyCallMode, [|#2|, |$...$|, |#3|]: TermTemplate?)}}
	{\mintinline{text}{PythonCall(|#1|, [|#2|, |$...$|, |#3|])}}}

\newcommandx{\ApplyMetafunction}[3][1=$mf$, 2=$t_m$, 3=true]{%
	\ifthenelse{\boolean{#3}}
	{\mintinline{text}{ApplyMetafunction(|#1|: str, |#2|: TermTemplate)}}
	{\mintinline{text}{ApplyMetafunction(|#1|, |#2|)}}}

\newcommandx{\DFSColor}[2]{%
	{\mintinline{text}{color(|#1|) =|\bfseries{#2}|}}}

\newcommandx{\LetDefineLanguage}[1]{\mintinline{text}{DefineLanguage |#1|}}


\newcommandx{\RepeatNoArg}{%
	{\mintinline{text}{Repeat}}}

\newcommandx{\TlDefineLanguage}[3][1=$n$, 2=$nt_1$, 3=$nt_m$]{%
\mintinline{text}{DefineLanguage(|#1|: string, [|#2|, |$...$|,|#3|]: NtDefinition)}}

\newcommandx{\TlDefineMetafunction}[7][1=$n$, 2=$l$, 3=$domain$, 4=$codomain$, 5=$mc_1$, 6=$mc_n$, 7=true]{%
	\ifthenelse{\boolean{#7}}
{\mintinline{text}{DefineMetafunction(|#1|: str, |#2|: str, |#3|: Pattern, |#4|: Pattern, [|#5|, |$...$|, |#6|]: MetafunctionCase)}}
{\mintinline{text}{DefineMetafunction(|#1|, |#2|, |#3|, |#4|, [|#5|, |$...$|, |#6|])}}}

\newcommandx{\MetafunctionCase}[3][1=$p$, 2=$t$, 3=true]{%
	\ifthenelse{\boolean{#3}}
	{\mintinline{text}{MetafunctionCase(|#1|: Pattern, |#2|: TermTemplate)}}
	{\mintinline{text}{MetafunctionCase(|#1|, |#2|)}}}

\newcommandx{\TlDefineReductionRelation}[6][1=$n$, 2=$l$, 3=$domain$, 4=$rc_1$, 5=$rc_n$, 6=true]{%
\ifthenelse{\boolean{#6}}
{\mintinline{text}{DefineReductionRelation(|#1|: str, |#2|: str, |#3|: Pattern?, [|#4|, ..., |#5|]: ReductionCase)}}
{\mintinline{text}{DefineReductionRelation(|#1|, |#2|, |#3|, [|#4|, ..., |#5|])}}}

\newcommandx{\ReductionCase}[4][1=$p$, 2=$t$, 3=$n$, 4=true]{%
	\ifthenelse{\boolean{#4}}
	{\mintinline{text}{ReductionCase(|#1|: Pattern, |#2|: TermTemplate, |#3|: str)}}
	{\mintinline{text}{ReductionCase(|#1|, |#2|, |#3|)}}}


%\newcommand{\ReductionCase}{\lstinline[mathescape]!ReductionCase($p$: Pattern, $t$: Term, $n$: string)! } 

\newcommandx{\Match}[5][1=$s_1$, 2=$t_1$, 3=$s_n$, 4=$t_n$, 5=true]{%
	\ifthenelse{\boolean{#5}}
	{\mintinline{text}{Match([(|#1|, |#2|), |$...$|, (|#3|, |#4|)]: Tuple(string, Term)?)}}
	{\mintinline{text}{Match([(|#1|, |#2|), |$...$|, (|#3|, |#4|)])}}}

\newcommandx{\RedexMatchAssertEqual}[6][1=$l$, 2=$p$, 3=$t$, 4=$m_1$, 5=$m_n$, 6=true]{%
	\ifthenelse{\boolean{#6}}
	{\mintinline{text}{RedexMatchAssertEqual(|#1|: str, |#2|: Pattern, |#3|: TermTemplate, [|#4|, ..., |#5|]: Match?)}}
	{\mintinline{text}{RedexMatchAssertEqual(|#1|, |#2|, |#3|, [|#4|, |$...$|, |#5|])}}}

\newcommandx{\TermLetAssertEqual}[9][1=$v_1$, 2=$n_1$, 3=$t_1$, 4=$v_m$, 5=$n_m$, 6=$t_m$, 7=$t$, 8=$e$, 9=true]{%
	\ifthenelse{\boolean{#9}}
	{\mintinline{text}{TermLetAssertEqual([(|#1|, |#2|, |#3|), |$...$|, (|#4|, |#5|, |#6|)]: Tuple(string, natural, TermTemplate)?, |#7|: TermTemplate, |#8|: TermTemplate)}}
	{\mintinline{text}{TermLetAssertEqual([(|#1|, |#2|, |#3|), |$...$|, (|#4|, |#5|, |#6|)], |#7|, |#8|)}}}


\newcommandx{\ApplyReductionRelationAssertEqual}[5][1=$r$, 2=$t$, 3=$e_1$, 4=$e_n$, 5=true]{%
	\ifthenelse{\boolean{#5}}
	{\mintinline{text}{ApplyReductionRelationAssertEqual(|#1|: str, |#2|: TermTemplate, [|#3|, |$...$|, |#4|]: TermTemplate?)}}
	{\mintinline{text}{ApplyReductionRelationAssertEqual(|#1|, |#2|, [|#3|, |$...$|, |#4|])}}}

\newcommandx{\ReadFromStdinAndApplyReductionRelation}[2][1=$r$, 2=$f$]{%
	\mintinline{text}{ReadFromStdinAndApplyReductionRelation(|#1|: str, |#2|: str)}}




\newcommand{\Repeat}{$Repeat(p_r)$}
\newcommand{\Nt}{$Nt(nt, s)$ }
\newcommand{\InHolePattern} {$InHole(p_1, p_2)$ }
%\newcommand{\UnresolvedSymbol}{$UnresolvedSymbol(s)$ }
\newcommand{\CheckConstraint}{$CheckConstraint(s_1, s_2)$ }

\newcommand{\CodeRepeat}{$Repeat(p_r)$}
\newcommand{\CodeCheckConstraint}{$CheckConstraint(sym_1, sym_2)$}

\newcommand{\DefineReductionRelation}{bfgfgf}

\newcommand{\DefineLanguage}{\lstinline[mathescape]!DefineLanguage($name$: string, \[$nt_1, ..., nt_m$\]: NtDefinition)! } 
\newcommand{\NtDefinition}{\lstinline[mathescape]!NtDefinition($nt$: Nt, \[$p_1, ..., p_n$\]: Pattern)! } 

\newcommand{\DefineMetafunction}{\lstinline[mathescape]!DefineMetafunction($name$: string, $domain$: Pattern, $codomain$: Pattern, \[$c_1, ..., c_n$\]: MetafunctionCase)! } 
%\newcommand{\MetafunctionCase}{\lstinline[mathescape]!MetafunctionCase($p$: Pattern, $t$: Term)! } 

%\newcommand{\ReductionCase}{\lstinline[mathescape]!ReductionCase($p$: Pattern, $t$: Term, $n$: string)! } 


\newcommand{\Visit}[1]{\texttt{visit}(#1)}

\title{My Dissertation - A very long title\\ which runs over two
  lines} %compulsory
\specialization{Dependable Distributed Systems}%optional
\subtitle{Subtitle: Reinventing the World} %optional 
\author{Master Student} %compulsory
\begin{committee}
\advisor{Prof.}{Student's}{Advisor} %compulsory
\coadvisor{Prof.}{Student's}{Co-Advisor}{} %optional
\end{committee}
\Day{Yesterday} %compulsory
\Month{September} %compulsory
\Year{2010} %compulsory, put only the year
\place{Lugano} %compulsory

\dedication{To my beloved} %optional
\openepigraph{Someone said \dots}{Someone} %optional

%\makeindex %optional, also comment out \theindex at the end

\begin{document}

\maketitle %generates the titlepage, this is FIXED

\frontmatter %generates the frontmatter, this is FIXED

\begin{abstract}
This is a very abstract abstract. 
\end{abstract}


\begin{acknowledgements}
	Hi Mom!
\end{acknowledgements}

\tableofcontents 
\listoffigures %optional
\listoftables %optional

\mainmatter
\input{chapters/01-introduction.tex}
\input{chapters/02-features-of-pltredex.tex}
\input{chapters/03-pypy-and-rpython.tex}
\input{chapters/04-PyPltRedex-runtime.tex}
\input{chapters/05-compiletime-racket-representation.tex}
\input{chapters/06-pattern-matching.tex}
\input{chapters/07-codegen.tex}
\input{chapters/08-toplevel-forms.tex}
\input{chapters/09-testing-evaluation.tex}
\input{chapters/10-conclusion.tex}


\chapter{ListListing example}
\lstset{language=algebra,linewidth=0.95\linewidth,breaklines=true,numbers=left,
basicstyle=\ttfamily,numberstyle=\tiny,escapeinside={//*}{\^^M},
mathescape=true}
\begin{lstlisting}
import IntSpec, ItemSpec;

sort cart; //*\label{sort}

constructors //*\label{begin-sig}
create() $\longrightarrow$ cart;
insert(cart, item) $\longrightarrow$ cart;
observers
amount(cart) $\longrightarrow$ int;
transformers
delete(cart, item) $\longrightarrow$ cart; //*\label{end-sig}

axioms //*\label{begin-axioms}
forall c: cart, i, j: item 

amount(create()) $=$ 0; //*\label{begin-amount}
amount(insert(c,i)) $=$ amount(c) $+$ price(i); //*\label{end-amount}
delete(create(),i) $=$ create(); //*\label{begin-delete}
delete(insert(c,i),j) $=$
if (i =$\:$= j) c
else insert(delete(c,j),i); //*\label{end-axioms}
end
\end{lstlisting}



\backmatter

\chapter{Glossary} %optional

%\bibliographystyle{alpha}
%\bibliographystyle{dcu}
\bibliographystyle{plainnat}
\bibliography{biblio}

%\cleardoublepage
%\theindex %optional, use only if you have an index, must use
	  %\makeindex in the preamble
\lipsum

\end{document}
