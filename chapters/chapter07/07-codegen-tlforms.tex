\section{Define-Language}
Given \DefineLanguage, the only thing left to do here is to generate a \texttt{isa} function for each $nt_i$. For each \NtDefinition:
\begin{enumerate}
\item Generate matching function $f_{p_i}$ for pattern $p_i$ and let $f_{p_i}^{top}$ be top-level matching function. 
\item Call $f_{p_i}^{top}$ with \texttt{term} as argument. Resulting list of matches is non-empty return True. 
\item Otherwise, none of patterns $p_i$ match the \texttt{term} and false is returned.
\end{enumerate}


\begin{minted}[tabsize=2,obeytabs,escapeinside=||,mathescape=true,fontsize=\small]{python}
{% def codegenNtDefinition(|$nt_i$|): %}
	{% |$f_{nt_i}$| =  symgen("isa_nt") %}
def |$f_{nt_i}$|(term):
	{% for |$p_i$| in |$nt_i$|=|$p_1, ..., p_n$|: %}
		{% |$f_{p_i}^{top}$| = codegenTopLevel($p_i$)
	matches = |$f_{p_i}^{top}$|(term)
	if len(matches) > 0:
		return True
	{% endfor %]
	return False
	{% return |$f_{nt_i}$| %}
{% enddef %}
\end{minted}



\section{Define-Metafunction}

Given \DefineMetafunction, related function accepts a term.

\begin{enumerate}
\item generate matching function $f_d$ for $domain$ pattern.
\item generate matching function $f_c$ for $codomain$ pattern.
\item Call $f_d$ with term, if resulting set of matches is empty raise Exception.
\item For each $c_i =$ \MetafunctionCase, generate function $f_{c_i}$, passing term as an argument.
\begin{enumerate}
	\item Generate matching function $f_{p}$ for pattern $p$
	\item Generate term-creation function $f_t$ for term-tempalate $t$.
	\item Call $f_p$ with the term passed as argument. If resulting list of matches is empty then return empty list.
	\item Otherwise, for each match $m_i$ call $f_t$. Store resulting $t_i^\prime$.
	\item Have to ensure that all $t_i^\prime$ are the same term. For each $t_i^\prime$ and $t_{i+1}^\prime$, they must be pairwise equal. If they are not, raise Exception.
	\item Return a single term.
\end{enumerate}
\item If $f_{c_i}$ returns a term, call $f_c$ with it as argument. If resulting list of matches is empty, raise Exception, otherwise return the term.
\item If $f_{c_i}$ doesn't return anything, continue with next metafunction case $f_{c_{i+1}}$
\item If none of metafunction cases were matched, throw Exception.
\end{enumerate}

\section{Define-Reduction-Relation}
Given \DefineReductionRelation, generate function accepting a single term. The function returns a list of terms. Code generation algorithm works in the following manner:

\begin{enumerate}
\item Generate function $f_d$ for $domain$, if $domain$ is present.
\item For each $r_i= $ \ReductionCase
	\begin{enumerate}
	\item Generate function $f_p$ for pattern $p$.
	\item Generate function $f_t$ for term-template $t$.
	\item Generate function $f_{r_i}$ for reduction case $r$ that accepts term as argument. Call $f_p$ and if resulting list of matches $m$ is not empty, let $t_i^\prime=f_t(m_i)$. If $domain$ is present, assert that $f_d(t_i^\prime)$ is not empty, otherwise raise Exception. Return a list containing $t_0^\prime, ..., t_n^\prime$, possibly empty.
	\end{enumerate}
\item Generate function for $rr$ accepting a single term. Let $ts^\prime$ be the list containing all the terms after applying reduction cases. Concatenate results of $f_{r_i}(term)$ with $ts^\prime$. Return $ts^\prime$.
\end{enumerate}

