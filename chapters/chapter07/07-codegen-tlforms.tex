\section{Define-Language}
Given \DefineLanguage, the only thing left to do here is to generate a \texttt{isa} function for each $nt_i$. For each \NtDefinition:
\begin{enumerate}
\item Generate matching function $f_{p_i}$ for pattern $p_i$ and let $f_{p_i}^{top}$ be top-level matching function. 
\item Call $f_{p_i}^{top}$ with \texttt{term} as argument. Resulting list of matches is non-empty return True. 
\item Otherwise, none of patterns $p_i$ match the \texttt{term} and false is returned.
\end{enumerate}


\begin{minted}[tabsize=2,obeytabs,escapeinside=||,mathescape=true,fontsize=\small]{python}
{% def codegenNtDefinition(|$nt_i$|): %}
	{% |$f_{nt_i}$| =  symgen("isa_nt") %}
def |$f_{nt_i}$|(term):
	{% for |$p_i$| in |$nt_i$|=|$p_1, ..., p_n$|: %}
		{% |$f_{p_i}^{top}$| = codegenTopLevel($p_i$)
	matches = |$f_{p_i}^{top}$|(term)
	if len(matches) > 0:
		return True
	{% endfor %]
	return False
	{% return |$f_{nt_i}$| %}
{% enddef %}
\end{minted}



\section{Define-Metafunction}

Given $mf=$ \DefineMetafunction, generate a function $f_{mf}$ that accepts a single \texttt{Term} instance.

\begin{enumerate}
\item generate matching functions $f_d$ for $domain$, $f_c$ for $codomain$ pattern, and let $f_d^{top}$, $f_c^{top}$ be top-level matching functions for $domain$ and $codomain$, respectively.
\item Code generation begins by call $f_d^{top}$ with term and ensuring that resulting list of matches isn't empty, otherwise Exception is raise.
\item For each $c_i =$ \MetafunctionCase, generate function $f_{c_i}$, passing term as an argument.
\begin{enumerate}
	\item Generate matching function $f_{p_i}$ for pattern $p_i$, and term-creation function $f_{t_i}$ for term-tempalate $t_i$. Let $f_{p_i}^{top}$ be top-level matching function for pattern $p_i$.
	\item Call $f_{p_i}^{top}$ with the term passed as argument. If resulting list of matches \texttt{matches} is empty then return empty list. Otherwise, for each \texttt{match} in \texttt{matches}, call $f_{t_i}$ and accumulate resulting terms into list \texttt{terms}.
	\item Have to ensure that all terms in \texttt{terms} are the same term. Metafunctions allow for non-deterministic behaviour during pattern-matching but resulting \texttt{Match} instances must always produce the same term.  Call function \texttt{aretermsequalpairwise} with \texttt{terms} and raise \texttt{Exception} if False is returned. Otherwise, pick any term from \texttt{terms}, and return it.
	This completes code generation of \MetafunctionCase.
\end{enumerate}
\item If $f_{c_i}$ returns a term, call $f_c^{top}$ with the term aas argument. If resulting list of matches is empty, then raise Exception, otherwise call $f_c^{top}$ with the only term in the list. If resulting list of matches is empty, raise Exception, otherwise return the term. If $f_{c_i}$ doesn't return anything, continue with next metafunction case $f_{c_{i+1}}$
\item If after calling $f_{c_1}, ..., f_{c_n}$ no terms are returned, none of the metafucntion cases were matches and Exception is thrown.
\item If none of metafunction cases were matched, throw Exception.
\end{enumerate}

Pseudo-code for this can be seen below:

\begin{minted}[tabsize=2,obeytabs,escapeinside=||,mathescape=true,fontsize=\small]{python}
{% def codegenDefineMetafunction(|$domain$, $codomain$, $c_1, ..., c_n$|): %}
	{% |$f_{mf}$| =  symgen("metafunction") %}
	{% |$f_d^{top}$, $f_c^{top}$| = codegenTopLevel($domain$), codegenTopLevel($codomain$) %}
def |$f_{mf}$|(term):
	if len(|$f_d^{top}$|) == 0: 
		raise Exception("domain check failed")
	{% for |$c_i$| in |$c_1, ..., c_n$|: %}
		{% |$f_{c_i}$| = codegen(|$c_i$|) %}
	nterm = |$f_{c_i}$|(term)
	if len(nterm) == 1:
		if len(|$f_d^{top}$|(nterm[0])) == 0:
			raise Exception("co-domain check failed")
		return nterm[0]
	{% endfor %}
	raise Exception("no metafunction case matched")
{% return |$f_{mf}$| %}
{% enddef %}

{% def codegenMetafunctionCase(|$p_i$, $t_i$|): %}
	{% |$f_{c_i}$| =  symgen("metafunctioncase") %}
	{% |$f_{p_i}^{top}$| = codegenTopLevel(|$p_i$|) %}
	{% |$f_{t_i}$| = codegenTermTemplate(|$t_i$|) %}
def |$f_{c_i}$(term):
	terms = []
	matches = |$f_{p_i}^{top}$|(term)
	if len(matches) == 0: return terms 
	for match in matches:
		terms.append(|$f_{t_i}$.|(match))
	if not aretermsequalpairwise(term):
		raise Exception("produced multiple terms")
	return [terms[0]]
{% return |$f_{c_i}$| %}
{% enddef %}
\end{minted}

\section{Define-Reduction-Relation}
Given $red=$ \DefineReductionRelation, generate function $f_{red}$ accepting a single term. The function returns a list of terms. Code generation algorithm works in the following manner:

\begin{enumerate}
\item Generate top-level matching function $f_d^{top}$ for $domain$, if $domain$ is present, add call $f_d^{top}$ with \texttt{term}. If resulting list of matches is empty, raise Exception.
\item For each $r_i= $ \ReductionCase, generate function $f_{r_i}$.
	\begin{enumerate}
	\item Generate top-level matching function $f_p^{top}$ for pattern $p$, and generate function $f_t$ for term-template $t$.
	\item Inside $f_{r_i}$, $f_p^{top}$(term) is called, and each match in resulting lists of matches is fed into $f_t$ resulting in a term. Apply $f_d$ to the term, and if resulting list of matches is empty, raise Exception, otherwise append the term to list \texttt{terms}.
	\item return \texttt{terms}
	\end{enumerate}
\item In $f_{red}$ create empty list \texttt{outterms}. For each $r_i$ in $r_1, ..., r_n$, call appropriate $f_{r_i}$ and accumulate results into \texttt{outterms}.
\item Return \texttt{outterms}
\end{enumerate}

\begin{minted}[tabsize=2,obeytabs,escapeinside=||,mathescape=true,fontsize=\normalsize]{python}
{% def codegenDefineReductionRelation(|$red$|): %}
	{% |$f_{red}$| =  symgen("reductionrelation") %}
	{% |$f_d^{top}$| = codegenTopLevel($domain(r)$) %}
def |$f_{mf}$|(term):
	outterms = []
	{% for |$r_i$| in |$red$|[|$r_1, ..., r_n$|]: %}
		{% |$f_{r_i}$| = codegenReductionCase(|$r_i$|, |$f_d^{top}$|) %}
	outterms = outterms + |$f_{r_i}$|(term)
	{% endfor %}
	return outterms
{% return |$f_{mf}$| %}
{% enddef %}

{% def codegenReductionCase(|$r_i$, $f_d^{top}$|): %}
	{% |$f_{r_i}$| =  symgen("reductioncase") %}
	{% |$f_{p}^{top}$| = codegenTopLevel(|$p(r_i)$|) %}
	{% |$f_{t}$| = codegenTermTemplate(|$t(r_i)$|) %}
def |$f_{c_i}$|(term):
	terms = []
	matches = |$f_{p}^{top}$|(term)
	for match in matches:
		t = |$f_{t}$|(match)
		if len(|$f_d^{top}$|(t)) == 0:
			raise Exception("term outside domain")
		terms.append(t)
	return terms
{% return |$f_{r_i}$| %}
{% enddef %}
\end{minted}
