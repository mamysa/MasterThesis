\section{Define-Language}

The only required thing here is to generate a \texttt{isa} function for each non-terminal definition of the language. For each \NtDefinition:
\begin{enumerate}
\item Generate matching function for pattern $p_i$. Let $f_i$ be top-level matching function.
\item Call $f_i$ with \texttt{term} as argument. If $f_i$ returns true, return true.
\item If none of $f_i$ return True, none of the patterns $p_i$ match the term and thus false is returned.
\end{enumerate}



\section{Define-Metafunction}

Given \DefineMetafunction, related function accepts a term.

\begin{enumerate}
\item generate matching function $f_d$ for $domain$ pattern.
\item generate matching function $f_c$ for $codomain$ pattern.
\item Call $f_d$ with term, if resulting set of matches is empty raise Exception.
\item For each $c_i =$ \MetafunctionCase, generate function $f_{c_i}$, passing term as an argument.
\begin{enumerate}
	\item Generate matching function $f_{p}$ for pattern $p$
	\item Generate term-creation function $f_t$ for term-tempalate $t$.
	\item Call $f_p$ with the term passed as argument. If resulting list of matches is empty then return empty list.
	\item Otherwise, for each match $m_i$ call $f_t$. Store resulting $t_i^\prime$.
	\item Have to ensure that all $t_i^\prime$ are the same term. For each $t_i^\prime$ and $t_{i+1}^\prime$, they must be pairwise equal. If they are not, raise Exception.
	\item Return a single term.
\end{enumerate}
\item If $f_{c_i}$ returns a term, call $f_c$ with it as argument. If resulting list of matches is empty, raise Exception, otherwise return the term.
\item If $f_{c_i}$ doesn't return anything, continue with next metafunction case $f_{c_{i+1}}$
\item If none of metafunction cases were matched, throw Exception.
\end{enumerate}

\section{Define-Reduction-Relation}
Given \DefineReductionRelation, generate function accepting a single term. The function returns a list of terms. Code generation algorithm works in the following manner:

\begin{enumerate}
\item Generate function $f_d$ for $domain$, if $domain$ is present.
\item For each $r_i= $ \ReductionCase
	\begin{enumerate}
	\item Generate function $f_p$ for pattern $p$.
	\item Generate function $f_t$ for term-template $t$.
	\item Generate function $f_{r_i}$ for reduction case $r$ that accepts term as argument. Call $f_p$ and if resulting list of matches $m$ is not empty, let $t_i^\prime=f_t(m_i)$. If $domain$ is present, assert that $f_d(t_i^\prime)$ is not empty, otherwise raise Exception. Return a list containing $t_0^\prime, ..., t_n^\prime$, possibly empty.
	\end{enumerate}
\item Generate function for $rr$ accepting a single term. Let $ts^\prime$ be the list containing all the terms after applying reduction cases. Concatenate results of $f_{r_i}(term)$ with $ts^\prime$. Return $ts^\prime$.
\end{enumerate}

\section{Redex-Match-Assert-Equal}
Given \RedexMatchAssertEqual code generation proceeds in the following manner.

\begin{enumerate}
\item First, generate a list of expected matches $m$. For each $m_i =$ \Match, 
\begin{enumerate}

\item generate function $f_{t_i}$ for $t_i$. 
\item Let resulting term be $tt_i = f_{t_i}(Match())$ 
\item Create empty \texttt{Match} instance $match$, call $match$.\texttt{AddBinding}$(s_i)$ and $match$.\texttt{AddToBinding}$(tt_i)$. 
\item Append $match$ to $m$.
\end{enumerate}
\item Generate top-level matching function $f_p$ for pattern $p$.
\item Generate top-level matching function $f_t$ for pattern $t$.
\item Let $ms^\prime = f_p(f_t())$
\item Call \texttt{assert\_compare\_match\_lists}$(ms^\prime, m)$.
\end{enumerate}

\section{Term-Let-Assert-Equal}

Given \TermLetAssertEqual code generation proceeds in the following manner.

\begin{enumerate}
\item First, need to produce $Match()$ instance containing all pattern-variable $v_i$ assignments. Let $m=Match()$. For each $(v_i, n_i, t_i)$
	\begin{enumerate}
	\item Generate $f_{t_i}$ function for term $t_i$.
	\item $m$.\texttt{AddBinding}$(v_i)$ and $m$.\texttt{AddToBinding}$(v_i, f_{t_i}(Match()))$
	\end{enumerate}
\item Generate $f_t$ for term-template $t$ and $f_e$ for term-template $e$.
\item Call \texttt{asserttermsequal}$(f_t(m), f_e(Match()))$.
\end{enumerate}


\section{Apply-Reduction-Relation-Assert-Equal}

Given \ApplyReductionRelationAssertEqual
\begin{enumerate}
\item First, need to generate a list of expected terms $e$.
	\begin{enumerate}
	\item Generate function $f_{e_i}$ for term template $e_i$.
	\item Concatenate $f_{e_i}(Match())$ to $e$.
	\end{enumerate}
\item Generate function $f_t$ for term-template $t$.
\item Let $f_{red}$ be a function generated after visiting \texttt{define-reduction-relation} with name $r$. Let $a=f_{red}(f_t())$ be the list of terms after applying reduction relation.
\item Call $asserttermlistsequal(a, e)$.
\end{enumerate}
