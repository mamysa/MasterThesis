\section{Generating Code for Patterns}

\subsection{Introduction}

\begin{enumerate}
\item
`isa` procedure that accepts a term and decides (true/false) if it matches desired pattern. This is done by ensuring each term instance is of expected class (e.g. \texttt{Integer}) and additionally verifying side conditions (e.g. \texttt{natural} term must of class \texttt{Integer} and its value must be greater or equal to zero)
\item
Actual matching procedure that accepts a match object, a term, and two extra arguments `head` and `tail` which indicate a range of subterms in the term that haven't been matched yet. Successful matching increments value of \texttt{head} by one. In principle it should be possible to perform pattern matching bi-directionally but PyPltRedex doesn't implement this.
\item
Top-level matching procedure that accepts a term, initializes `Match` object with pattern-variables found in the pattern and calls matching procedure. `Match` objects filtered and returned.
\end{enumerate}


\subsection{Is-A Procedures}

So called Is-A procedures have the following interface:

\begin{lstlisting}
isa(term: Term) -> boolean
\end{lstlisting}

These procedures are produced for all built-in patterns excluding `(inhole pattern pattern)`.  Originally, most these procedures were generated by PyPltRedex dynamically but then I realized these could just a part of runtime library introduced in Chapter TODO. This allowed for great code generator simplification.

\begin{lstlisting}
def term_is_number(term):
    return isinstance(term, Float) or isinstance(term, Integer)

def term_is_integer(term):
    return isinstance(term, Integer) 

def term_is_float(term):
    return isinstance(term, Float) 

def term_is_natural_number(term):
    return isinstance(term, Integer) and term.value() >= 0

def term_is_hole(term):
    return isinstance(term, Hole) 

def term_is_string(term):
    return isinstance(term, String) 

def term_is_boolean(term):
    return isinstance(term, Boolean) 

def term_is_variable_not_otherwise_mentioned(term, variableset):
    return isinstance(term, Variable) and term.value() not in variableset
\end{lstlisting}

Figure above demonstrates \texttt{isa} procedures for \texttt{number}, \texttt{real}, \texttt{natural}, \texttt{string}, \texttt{boolean} and \texttt{variable-not-otherwise-mentioned} patterns. All of these use Python's built-in \texttt{isinstance} function to check if given term is of proper subclass of \texttt{Term} described in Chapter TODO.

Most of these procedures can be called directly. The only function that looks different is \texttt{term\_is\_variable\_not\_otherwise\_mentioned} and that is because a set of variables used by related \texttt{define-language} form is required and is not known until compile time. This is solved by creating a wrapper function. 

This completes description of \texttt{isa} procedures for now. \texttt{isa} functions are also generated for each non-terminal definition in \texttt{define-language} form and their generation will be explained later.


\subsection{Matching Procedure: Built-In Patterns and Non-terminals}
Given \BuiltInPattern or \Nt and equipped with \texttt{isa} functions defined above (also assuming \texttt{isa} functions for non-terminal definitions have been generated), upon successful application of appropriate \texttt{isa} procedure, \texttt{head} must be incremented by one and term must be assigned to pattern-variable $s$. The choice of \texttt{isa} procedure depends on $t$.

Generated code does the following:

\begin{enumerate}
\item Call appropriate \texttt{isa} procedure. 
\item If result is True, add term to the \texttt{match} under appropriate pattern-variable, increment \texttt{head} by one and return a list containing \texttt{(match, head, tail)} tuple.
\item Otherwise, return an empty list.
\end{enumerate}


\begin{minted}[tabsize=1,obeytabs,escapeinside=||,mathescape=true,linenos,fontsize=\small]{python}
|$f_p$| = Symgen("match_pattern")
|$isa_p$| = codegen_IsA(term)
emit <<
def |$f_p$|(match, term, head, tail):
	tmp0 = |$isa_p$|(term)
	if tmp0 == True:
		tmp1 = match.addtobinding(|$s$|, term) 
		head = head + 1
		return [(match, head, tail)]
return []
>>
return |$f_p$|

\end{minted}

\subsection{Matching Function: Ellipsis}
Repeat Recall that patterns under ellipsis match lists of terms and can only be contained in pattern sequences and thus \texttt{term} argument is always to be expected to be \PatternSequence. Non-deterministic matching repetition of terms is handled in the following way. Given \Repeat, let $pattern-variables(p)$ be the set of pattern-variables in pattern $p$. It is obtained from reading annotation TODO, as described in Chapter/Section TODO. 

\begin{enumerate}
\item
For each symbol in $pv(p)$, call `increasedepth` method of `match` object. This will push an empty term sequence onto the stack. (see Match object design in Chapter ??)
\item
Create a list of matches to be returned later. It is initialized with initial `match`, `head`, `tail` procedure arguments.
\item
Initialize a queue of matches with same initial `match`, `head`, `tail` arguments. The reason why queue is needed to store usual `(match, head, tail)` tuples because $p$ may contain non-deterministic ellipsis matching and hence to obtain all desired matches a matching procedure under ellipsis also needs to be called on such matches.
\item While queue is non-empty:
	\begin{enumerate}
	\item 
	Remove `(match, head, tail)` from the queue. If `head` and `tail` are equal then it means all elements of the sequence have been matched and there's nothing left to do.  Otherwise, create a copy of `match` object (which will also copy terms stored in `match`)
	\item
	Retrieve an element at index \texttt{head} of the term sequence and call matching procedure for pattern under ellipsis. Add newly obtained matches both to `matches` and queue.
	\end{enumerate}

\item
* For each obtained `match` object call `decreasedepth` method. This completes matching the list of terms.
\item
Return \texttt{matches}
\end{enumerate}




\subsection{Matching Function: PatternSequence}

Matching pattern sequences is more involved. This assumes that subpatterns have been generated already and names of procedures are known. 

\begin{enumerate}
\item
* First, given term must be a sequence. If it is not, an empty list is returned.
\item
* Then, the term has to be "entered" to be ready for matching; that is, to be able to use subpattern procedures to match subterms new values for `head` and `tail` are required. Initialize `nhead=0` and set `ntail` to be length of the term sequence - these will be used to track which elements of the term haven't been matched yet.
\item
* Before matching elements of the term, need to ensure that number of said elements is greater or equal to the number of elements in the pattern sequence excluding patterns under ellipses and constraint checking nodes. Terms with too few elements do not match the pattern. For example, term `(3)` does not match pattern `(n\_1 n\_2 ... n\_3)` as `n\_1` and `n\_3` have to be matched exactly.
\item
* Create an empty list of matches and initialize it with `(match, ntail, nhead)` pattern.
\item
* Now, we can start matching individual elements of the term according to the elements of the pattern sequence. There are few cases to consider here. Ellipses and constraint checks have to be handled separately from everything else.  Ellipses are handled in their own procedure and it must be provided the entire term; constraint checks do not actually match anything.
\item
* For each tuple `(m, h, t)` in the list of matches:
\item
* If given element `e` with offset `i` in pattern sequence is Ellipses (Repetition), simply call repetition procedure with arguments `(m, term, h, t)`. For each of obtained matches, we need to ensure number of unmatched elements in the term is greater or equal to number of non-optional patterns between `i` and length of the sequence. Matches not satisfying requirement above are discarded. If the list of matches after filtering is empty, given term does not match the pattern at all. Code snippet below demonstrates matching patterns under ellipses in pattern sequences.

TODO REWRITE THIS 
\end{enumerate}

\subsection{Ellipsis: Example}
\input{chapters/chapter07/07-ellipsis-example.tex}

\subsection{Match Function: InHole pattern}
Given pattern \InHolePattern, let $f_p^{impl}$ name of the function for \texttt{in-hole} pattern. Recall that \texttt{in-hole} pattern is annotated with pattern-variables during "Pattern Variable Extraction" pass described in Section TODO. Let $pv_i^{(p_1)}$ and $pv_i^{(p_2)}$ be annotations for $p_1$ and $p_2$. Finally, generate functions for $p_1$ and $p_2$ and let them be $f_{p_1}$ and $f_{p_2}$ respectively. 

Notice that this function contains extra parameter \texttt{path}, which is used to keep track of path to possible \texttt{hole}. To conform to established interface, a wrapper function will be generated later.

Since $p_1$ and $p_2$ are self-contained patterns with possible non-deterministic behaviour, \texttt{match} cannot be passed to $f_{p_1}$ and $f_{p_2}$ as is. Instead, create special \texttt{Match} instances to be passed to $f_{p_1}$ and $f_{p_2}$ that are initialized with $pv_i^{(p_1)}$ or $pv_i^{(p_2)}$ accordingly.

First, call $f_{p_2}$ with appropriate match, if resulting list of matches is non-empty, do the following: (1) append current term to the path; (2) call path copying function thus replacing the term with \texttt{hole} and (3) call $f_{p1}$ with appropriate match. If resulting set of matches is not empty, increment \texttt{head} (without overwriting it!) by one signalling successful matching of \texttt{in-hole} pattern, combine resulting matches of $f_{p_1}$ and $f_{p_2}$ with initial \texttt{match} as explained in Section TODO, and append to \texttt{matches}.

If given \texttt{term} is \texttt{Sequence}, continue matching \texttt{in-hole} pattern. Each element of the sequence is added to the path, $f_p^{impl}$ is called with said element, resulting matches are added to \texttt{matches} and topmost term in the \texttt{path} is popped. Resulting \texttt{matches} are returned.

%\setlength\LTleft{-65pt}% 2.5cm into the left margin
\begin{tabular}{|c|p{0.97\textwidth}|}
\hline 
\cellcolor{blue}1 & 
\begin{minted}[tabsize=1,obeytabs,escapeinside=||,mathescape=true,fontsize=\small]{python}
def codegenInHole(inhole):
	|$f_p^{impl}$| = symgen("match_pattern_impl")
	|$pv_1^{(p_1)}, ..., pv_n^{(p_1)}$| = |$p_1$|.getannotation(PatternVariables)
	|$pv_1^{(p_2)}, ..., pv_m^{(p_2)}$| = |$p_2$|.getannotation(PatternVariables)
	|$f_{p_1}, f_{p_2}$| = codegen(|$p_1$|), codegen(|$p_2$|)
\end{minted} 
\\
\hline 
\cellcolor{red}2 &
\begin{minted}[tabsize=1,obeytabs,escapeinside=||,mathescape=true,fontsize=\small]{python}
def |$f_p$|(term, match, head, tail, path):
	matches = []
	p2match = Match([|$pv_1^{(p_2)}, ..., pv_m^{(p_2)}$|])
	p2ms = |$f_{p_2}$|(term, p2match, 0, 1)
	if len(p2ms) != 0:
		p1match = Match(|$pv_1^{(p_1)}, ..., pv_n^{(p_1)}$|)
		npath = path + [term]
		nterm = copy_path_and_replace_last(tmp0, hole)
		p1ms = |$f_{p_1}$|(nterm, p1match, 0, 1)
		if len(p1ms) != 0:
			nhead = head + 1
			ms = match_cartesian_product_add_binding_to(
				p1ms, p2ms, match, nhead, tail)
			matches = matches + ms
\end{minted} 
\\
\hline
\cellcolor{green}3 & 
\begin{minted}[tabsize=1,obeytabs,escapeinside=||,mathescape=true,fontsize=\small]{python}
	if isinstance(term, Sequence):
		path.append(term)
		for i in range(term.length()):
			childterm = term.get(i)
			results= |$f_p^{impl}$|(childterm, match, 
								    head, tail, path)
			matches = matches + results 
		path.pop()
	 return matches 
\end{minted} 
\\
\hline
\end{tabular}

%\end{adjustwidth}

Finally, to get rid of \texttt{path} parameter from signature of $f_p^{impl}$, a wrapper function $f_p$ is generated. Additionally, it also handles constraint checks $c_i$ if applicable. Since constraint checks are optional, there are two cases to consider.

\begin{enumerate}
\item No constraint checks - simple return \texttt{matches}
\item Constraint checks are present - for each constraint check generate a call to \texttt{Match.comparekeys} function. This is done for each match returned by calling $f_p^{impl}$.
\end{enumerate}

\begin{minted}[tabsize=2,obeytabs,escapeinside=||,mathescape=true,fontsize=\small]{python}
{% |$f_p$| = symgen("match_pattern") %}
def |$f_p$|(match, head, tail):
	matches = |$f_p^{impl}$|(match, head, tail, [])
{% if constraintchecks != None %}
		nmatches = []
		for m, h, t in matches:
	{% for |$c_i$ = \CheckConstraint| in |$c_1, ..., c_n$|: %}
			if not m.comparekeys(|$s_1$|, |$s_2$|):
				continue
			nmatches.append((m, h, t))
	{% endfor %}
		return nmatches
{% else %}
		return matches
{% endif %}
\end{minted} 

\subsection{Top-Level Matching Function}

This procedure creates `Match` object, initializes it with assignable symbols seen in the actual pattern and calls appropriate matching procedure. `head` and `tail` parameters are set to zero and one, respectively. Since matching procedure returns a list of `(match, head ,tail)` tuples, `Match` objects are filtered out and returned.

