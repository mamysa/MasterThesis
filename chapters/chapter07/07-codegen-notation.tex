\section{Notation}

A few words about notation; the original intent was to simply reuse Python code but it turned out to be not particularly space-friendly. Instead, to stay consistent with the notation described in Chapter \ref{chapter05}, the following notation for code-generation is used, as seen in the code snippet below.


\begin{minted}[tabsize=2,obeytabs,escapeinside=||,mathescape=true,fontsize=\normalsize]{pythoncomplexer.py:PythonCompLexer -x}
{% def codegenSomething(p): %}
	{% |$f_p$| = Symgen("match_pattern") %}
def |$f_p$|(match, term, head, tail):
	return None
{% return |$f_p$| %}
{% enddef %}
\end{minted}

\begin{itemize}
\item Statements between \texttt{\{\%} and \texttt{\%\}} are Python statements executed by the compiler. Statements that are not, are generated RPython code.
\item Variables such as $f_p$ are \textit{meta-variables}; when a meta-variable is used in description of generated RPython code, an actual value assigned to it will be emitted instead.
\item Special \texttt{endfor}, \texttt{enddef}, \texttt{endif} are used to indicate an end of Python block.
\item Occasionally, there's a need for iterative Python statement generation, based on contents of a pattern or term-template. Array reference is used to retrieve fields of compile-time objects.

\end{itemize}
