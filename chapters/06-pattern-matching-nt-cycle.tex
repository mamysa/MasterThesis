\section{Non-Terminal Cycle Checking}

\subsection{Motivation}
PltRedex disallows language definitions such as ones in Figure below. 

\begin{lstlisting}
(define-language L
	(e ::= (e e) n)
	(n ::= (n n) number p)
	(p ::= (p p) real e))
	(s ::= string)
\end{lstlisting}

The problem with the language above (aside from it being completely useless) is a cycle of non-terminals $n \rightarrow p \rightarrow e$. When testing if some term is a non-terminal, a term is matched against every pattern in non-terminal definition. For example, given term \texttt{String("hello world")} it is matched against non-terminal \texttt{e}. Since  the term doesn't match pattern \texttt{(e e)}, non-terminal \texttt{n} is then matched. Since the term doesn't match any patterns here either, non-terminal \texttt{p} is then matched. Similarly, the term doesn't match any patterns here either, \texttt{e} is then matched, but that's where the matching has started and thus \textit{infinite recursion} becomes an issue. Languages need to be analyzed for presence of non-terminal cycles.

\subsection{Algorithm}
To detect such cycles, \texttt{define-language} needs to be interpreted as directed graph and some cycle-detecting algorithm must be used. Graph is constructed in the following manner.

TODO fix notation here

\begin{enumerate}
\item
For each \NtDefinition, create a vertex with label $s=nt$.
\item
For $p_1, ..., p_n$, if $p_i$ is $\Nt$ then create edge $s->nt$.
\end{enumerate}


For cycle detection, depth-first-search is employed. Vertices in the graph can be assigned one of three colors:

\begin{itemize}
\item

\textbf{White} meaning the vertex hasn't been visited before. All vertices are initially assigned this color.

\item
\textbf{Grey} meaning successors of the vertex $v$ are still being visited. When $v$ is visited for the first time, $color(v)$ becomes \textbf{Grey}.
\item
\textbf{Black} meaning all successors of the vertex $v$ have been explored. 
\end{itemize}



Vertex coloring allows for detection of cycles; more specifically, if during depth-first-traversal vertex $v$ is encountered with $color(v)=Grey$, this means that there's a \textbf{back-edge} in dfs-tree. (expand). That is, back-edge (u,v) connects vertex $v$ to its predecessor in depth-first-search tree $u$. Once such cycle is found, the error is reported and compilation aborts.

To report a path of non-terminals that make up the cycle, a path of non-terminals has to be maintained. The path can be represented as a stack. The vertex is added to the stack when it changes color to $Grey$ and removed from the stack when it changes color to $Black$. Pseudocode for depth-first-traversal and cycle reporting can be seen below.


\begin{minted}[tabsize=2,obeytabs,escapeinside=||,mathescape=true,linenos]{python}
def reportcycle(path, v):
	idx = path.indexof(v)
	cyclepath = path[idx:] + [v]
	raise CompilationError(nt cycle {}.format(cyclepath))

def visit_vertex(v, V, path):
	if v.color == White:
		path.append(v)
		v.color = Grey 
		for successor in v.successors:
			self.visit(successor, V, path)
		v.color = Black
		V = V.union(v)
		path.pop()
	if v.color == Discovered:
		reportcycle(path, v)
\end{minted}

Since resulting non-terminal graphs may be disjoint, we need to keep track of visited vertices during traversal. Let $V$ be a set of vertices whose $color(v)=Black$. Thus, every time vertex $v$ changes its color to $Black$, $V = V \cup \{v\} $. Let $U$ be a set of vertices whose $color(u)=White$; that is, it initially contains all the non-terminals. The algorithm proceeds as follows:

\begin{enumerate}
\item
Pick random vertex $u$ from set $U$. Create empty set $V$. Starting from $u$ perform depth-first-search as described above. Compute set difference - $U = U-V$.
\item
Continue until $U$ is empty.
\end{enumerate}

Pseudo-code for this procedure can be seen below.

\begin{lstlisting}
def visit_graph(graph):
	U = set(self.nts)
	while len(U) != 0:
		V = set()
		self.visit(U.get_random_element(), V, [])
		U = U - V
\end{lstlisting}

\subsection{Improvements}
Note that the described algorithm does not report all the cycles in the graph but the first one it manages to find.

report all potential cycles in the graph
